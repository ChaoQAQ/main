star明星
constructor构造函数的意思
constructor 函数 只要 new 生成实列时 就会自动调用这个函数 如果我们不写这个函数 类也会自动生成这个函数
类里面有个 constructor 函数 可以接受传递过来的参数 同时返回给实例化对象 所有不用写 return
sing唱
song歌曲
extends延伸扩展 extends关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。
extends关键字用来创建一个普通类或者内建对象的子类
super超级的 super关键字用于访问和调用一个对象的父对象上的函数 可以调用父类的构造函数也可以调用父类的普通函数
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。super关键字也可以用来调用父对象上的函数
利用 super 关键字调用父类的构造函数 super 必须在子类this之前调用
子类继承父类后 必须super在子类this之前调用 否则报错 
subtract减
在 ES6 中类没有变量提升 所以必须先定义类 才能通过类实例化对象
类里面的共有属性和方法一定要加 this 使用
constructor里面的this指向实例对象 方法里面的this指向这个方法的调用者
可以声明全局变量 把this指向的赋值给变量 使用变量当this使用
that那个的意思
dance跳舞 舞蹈
insertAdjacentHTML() 方法将指定的文本解析为 Element 元素，并将结果节点插入到DOM树中的指定位置 插入 相邻 html
element.insertAdjacentHTML(插入元素的位置, 插入的元素);  插入的元素如果是字符串可以解析为html标签
Node.appendChild只能插入节点不能转义html标签
beforebegin元素自身的前面 begin开始
afterbegin插入元素内部的第一个子节点之前
beforeend插入元素内部的最后一个子节点之后 end结束
afterend元素自身的后面
HTMLInputElement.select() 方法选中一个 <textarea> 元素或者一个带有 text 字段的 <input> 元素里的所有内容。
ondblclick鼠标双击事件
// new 在执行的时候会做四件事情
(1) 在内存中创建一个新的对象
(2) 让this指向这个新的对象
(3) 执行构造函数里面的代码 给这个新对象添加属性和方法
(4) 返回这个新对象 所以构造函数里面不需要return
 javascript构造函数中可以添加添加一些成员 可以在构造函数本身上添加 也可以在构造函数内部的this上添加
静态成员 在构造函数本身上添加的成员 sex 就是静态成员 Star.sex = '男'; 静态成员只能通过构造函数来访问
实例成员 就是构造函数内部通过 this 添加的成员 uname age sing 就是实例成员 实例成员只能通过实例化的对象来访问
prototype构造函数的原型对象 方法共享 是每一个构造函数都有的一个属性 指向另一个对象 这个对象的所有属性和方法都会被构造函数所拥有
__proto__是对象自己的一个属性对象原型 会指向构造函数里面的原型对象 
对象原型和构造函数的原型对象里面都有一个属性 constructo属性 我们称为构造函数 因为它指回构造函数本身
constructor 主要用于记录对象引用于哪个构造函数 它可以让原型对象重新指回原来的构造函数
如果我们修改了原来的原型对象 给原型对象赋值的是一个对象 则必须手动的利用 constructor指回原来的构造函数
原型对象也是对象 只要是对象就有 __proto__ 对象原型 指向原型对象
我们Star原型对象里面的 __proto__ 对象原型指向的是Object.prototype
我们Object.prototype 原型对象里面的 __proto__ 对象原型 指向为 null
1. 当访问一个对象的属性和方法时 首先查找这个对象自身有没有
2. 如果没有就查找这个对象的原型 对象原型指向原型对象构造函数本身
3.如果函数没有就找原型对象的对象原型指向Object的原型对象
4. 依次类推一直找到Object 为止 null
5. __proto__ 对象原型的意义就在于为对象成员查找机制提供一个方向 或者说一条线
1. 在构造函数里 this 指向的是对象实例 ldh
2. 原型对象函数里面的this 指向的也是 实例对象 ldh
3. 一般情况下 this 指向函数的调用者
数组和字符串内置对象不能给原型对象赋值操作 只能给原型对象添加方式
call( ) 呼叫 可以调用函数 也可以改变this指向
call()方法调用父构造函数 并把父类构造函数的this指向子类的this 这样就实现了类继承父类属性
new Father() 创建了一个新的对象实例 地址赋值给Son的原型对象 而Father的原型对象有__proto__对象原型会指向Father的原型对象
 因此首先了继承方法 又因为Son的原型对象被改变了里面的constructor指向了Father 所以需要手动改回来
Son.prototype = new Father();
Son.prototype.constructor = Son;
 // (1) 构造函数有原型对象 prototype
        // (2) 构造函数原型对象 protype 里面有 constructor 指向构造函数本身
        // (3) 构造函数可以通过原型对象添加方法
        // (4) 构造函数创建的实例对象有__proto__原型指向 构造函数的原型对象
        // ES6 通过 类 实现面向对象编程
        // 1. 类的本质其实还是一个函数 我们可以简单的认为 类就是 构造函数的另一种写法
        // (1) 类有原型对象 prototype
        // (2) 类原型对象prototype 里面有 constructor 指向类本身
        // (3) 类可以通过原型对象添加属性和方法
        // (4) 类创建的对象有__proto__对象原型指向 类的原型对象
forEach（function(当前数组元素，当前数组元素索引号，当前被遍历的数组) { }）遍历数组
filter 过滤器 筛选数组 filter 不会改变原数组，它返回过滤后的新数组
some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值
1. filter 也是查找满足条件的元素 返回一个新数组 而且是返回所有元素
2. some 也是查找满足条件的元素 返沪一个布尔值 如果找到第一个满足条件的后就终止循环
map() 地图 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
every() 每一个 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
在 some里面 return true会终止 迭代 遍历 效率跟高
trim() 修剪 方法会从一个字符串的两端删除空白字符 返回一个新的字符串
Object.keys(目标对象) key键 遍历对象属性名 返回一个数组 存放的是该对象的属性名 类似于 for in
Object.defineProperty(目标对象，修改或者添加的属性名字符串格式，{特性  }) 定义 特性 方法会直接在一个对象上定义一个新属性，
或者修改一个对象的现有属性，并返回此对象
value 修改或者添加
writable 是否允许重写修改value值 默认false
enumerable 是否可枚举遍历属性 默认false
configurable 是否可删除该属性 是否可修改该属性的特性
instanceof  例子 用于检测前者属不属于后者 返回一个布尔值 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
Math.max() 函数返回一组数中的最大值
call() 方法第一个可以调用函数 第二个可以改变函数内的this指向 call() 主要作用可以实现继承
apply() 也是调用函数 第二个也可以改变函数内部 this 的指向 但是它的参数必须是数组(伪数组)
bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
如果有函数我们不需要立即执行 但是又想改变这个函数内部的 this 指向 此时用 bind() 比如定时器
'use strict' 使用 严格模式 开启严格模式
1. 我们的变量必须先声明在使用
2. 我们不能随意删除已经声明好的变量
3. 严格模式下 全局作用域中的函数 this 指向 undefined 普通模式是 window
4. 严格模式下 构造函数必须 加new 调用 否则当普通函数 this指向undefined 就会报错
5. 定时器 this 还是指向 window 回调函数 this 还是指向调用者
6. 严格模式下函数里面的参数不允许有重名
高阶函数就是 把函数当作参数传递 或者 将函数作为返回值输出
闭包 closure 指有权访问另一个函数作用域中变量的函数
闭包 我们fun这个函数作用域 访问了另一个函数 fn 里面的局部变量 num
一个函数访问了另一个函数的局部变量 这个局部变量所在的函数就是闭包 我们就称这个被访问的函数叫做闭包 
我们 fn 外面的作用域可以访问 fn 内部的局部变量 num

闭包是一个函数 一个作用域可以访问另外一个函数的局部变量 闭包的主要作用 延伸了变量的作用范围 
闭包让你可以在一个内层函数中访问到其外层函数的作用域

scope作用域范围
Global全球 全局作用域
Local 地方的 局部作用域
Closure闭包
循环是同步任务 循环执行完毕后 在执行异步任务
递归函数 递归函数就是函数内部自己调用自己 这个函数就是递归函数
浅拷贝只是拷贝一层 更深层次对象级别的只拷贝引用地址
 深拷贝数据是拷贝多层数据 每一级别的数据都会被拷贝
console.log/dir/... 这类方法输出对象时会显示该对象在内存中最新的状态 所以先打印在修改对象属性 还是会打印出对象修改后的属性
Object.assign(目标对象，需要被拷贝的对象) assign分配的意思 是浅拷贝对象只拷贝一层数据
let 具有块级作用域 {} 里面有let声明的变量 for循环()里面声明的变量 全局作用域下无法访问 没有变量提升 不能先赋值在声明 不能在同一作用域下声明同一变量名
let 声明的变量没有在window里产生属性 所以window里面没有age这个属性
var 没有块级作用域 可以重复声明变量 有变量名提升 可以先赋值在声明
var 函数作用域 变量提升 值可更改
let 块级作用域 不存在变量提升 值可更改
const 声明常量 块级作用域 不存在变量提升 值不可更改 必须赋初始值 固定的值可以用const声明 这样浏览器解析js时就可以不用时刻监视这个数据的变化 效率就会提升
数组解构 允许我们按照一一对应的关系从数组中提取值 然后赋值给变量 没有被赋值的变量显示undefined
对象解构 允许我们使用变量的名字匹配对象的属性 匹配成功将对象属性的值赋值给变量
箭头函数是来简化函数定义语法的 因为箭头函数没有名字 所以我们经常把箭头函数赋值给一个变量 又因为函数名不可变型 所以用常量更好
箭头函数 函数体类只有一句代码时 并且代码的执行结果就是函数的返回值 此时函数体的大括号和 return 都可以省略
箭头函数中 如果只有一个形参 形参外面的小括号也可以省略
箭头函数不绑定 this 箭头函数没有自己的 this 关键字 如果在箭头函数中使用 this this关键字将指向函数定义位置的上下文this
箭头函数没有 arguments 这个对象 只有函数才有 arguments这个对象
 箭头函数形参可以写 (第一个，第二个，...剩余的参数) 剩余的参数以数组方式接受
也可以直接写 (...剩余参数) 就是接受所有参数返回一个数组 ...叫扩展运算符代表剩余的 ...后面的代表数组名 
...叫做扩展运算符 可以将数组拆分为以逗号分隔的参数序列 合并数组 数组克隆 伪数组转换为真数组
Array.from() 类型 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例 遍历伪数组 还可以处理每一项数据
find() 发现 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined
findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
includes() 包含 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false
模板字符串 使用反引号定义 可以解析变量 ${变量名} 可以换行显示 可以调用函数 ${fn()}
startsWith() 开始 具有 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false
endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false
repeat() 重复 repeat方法将一个字符串重复n次
Ste 本身是一个构造函数 用来生成 Set 结构 Set 对象允许你存储任何类型的唯一值 无论是原始值或者是对象引用 不会存储或者添加相同数据
Set 是一个伪数组 可以用扩展运算符将他转换为真数组 这样就可以用数组里面的方法了
size 返回 Set 对象中的值的个数
1. add(value) 在 Set 尾部添加一个元素 返回 Set 对象
2. delete(value) 移除 Set 某个元素
3. has(value) 判断一个值是否在 Set 里面存在 返回布尔值
4. clear() 清除 Set 里面所有成员 没有返回值
1. 箭头函数的 this 是静态的 指向当前作用域的this
 2. 箭头函数适合与 this 无关的回调 定时器 数组方法回调
 3. 箭头函数不适合与 this 有关的回调 事件回调 对象的方法等
ES6 允许给函数形参赋值初始值 可以与解构赋值结合
ES5 获取实参的方式 arguments 返回一个对象 是一个伪数组 不能使用数组的方法
ES6 引入 rest 参数 用于获取函数的实参 用来代替 arguments 返回一个真数组 是剩余参数组成的数组 可以使用数组方法
undefined String Symbol Object Number null Boolean

Symbol的原理：保证每一个属性名都是独一无二的，从根本上防止属性名的冲突。
symbol表示独一无二的值，是JavaScript的第七种数据类型
Symbol值通过Symbol函数，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。而Symbol类型的属性名都是独一无二的，保证不会与其他属性名发生冲突
1.Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
2.Symbol值不能与其他类型的值进行运算
3.Symbol值可以显式转为字符串
4.Symbol值可以转为布尔型，但不能转为数值。
由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖
1.Symbol作为对象属性名时，不能用点运算符。(点运算符后面总是字符串)
2.在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。方括号中的属性名代表了Symbol值。
3.Symbol 值作为属性名时，该属性还是公开属性，不是私有属性
Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
Object.getOwnPropertySymbols()：返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
Reflect.ownKeys()：返回所有类型的键名
Symbol.for()(重新使用同一个Symbol值)
它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。

 for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句
1. 创建一个指针对象 指向当前数据结构的起始位置
2. 第一次调用对象的 next 方法 指针自动指向数据结构的第一个成员
3. 接下来不断调用 next 方法 指针一直在往后移动 直到指向最后一个成员
4. 每调用 next 方法返回一个包含 value 和 done 属性的对象 value结束值 done就是迭代完毕没有 完了就是true

function* 生成器函数 它返回一个  Generator发电机  对象 生成器函数是一个特殊的函数 用于解决异步编程

yield 产量的意思 关键字 后面是表达式 返回一个对象 有 value 跟 done 属性 value 是表达式值 done 完成的意思 是一个布尔值 true 就是迭代完成

yield 关键字 会暂停生成器函数的执行  一个next 执行一句yield自己跟自己前面的代码

生成器函数传参 可以正常使用 

next 方法是生成器函数调用者的原型对象下的方法 可以 决定生成器函数执行 第一个next方法调用会执行到第一句 yield语句结束 不能进行传参

第二个开始 next 方法传递的参数将被第一个yield语句结束 并且作为这句 yield的返回值 依次内推

同步任务是主线程上排队执行 只有上一个任务执行完毕才会执行下一个任务

异步任务不进入主线程 而是进入异步队列 前一个任务是否完成不会影响后一个任务的执行

回调地狱 就是在异步函数中顺序执行而不断嵌套调用的回调函数

回调地狱就是为了实现异步任务执行代码顺序执行而出现的一种操作 它会造成我们的代码可读性非常差 后期不好维护

iterator迭代器

yield 产量 产出

Promise 是js中的一个原生对象 是一种异步编程的解决方案 可以替换掉传统的回调函数解决方案
Promise 构造函数接收一个函数作为参数 我们需要处理的异步任务就卸载该函数体内 该函数的连个参数是 resolve reject 异步任务执行成功时调用 resolve 函数返回结果 反之调用 reject
Promise 对象的 then 方法用来接收处理成功或者失败时响应的数据 catch 方法用来接收处理失败时相应的数据
Promise 对象的链式编程可以保证代码的执行顺序 前提是每一次在 then 处理完后 一定要 return 一个 Promise 对象 这样才能在下一次 than 时接收到数据
promise 许诺 答应
resolve 决定
reject 拒绝
reason 原因
then 然后
fulfilled 已完成
catch 拦截

if (err) throw err; 抛出错误 投
Console.warn() 向 Web 控制台输出一条警告信息

Map可以说是升级版的对象 Map 对象保存键值对 并且能够记住键的原始插入顺序任何值（对象或者原始值）都可以作为一个键或一个值
一个 Map 对象在迭代时会根据对象中元素的插入顺序来进行——一个 for...of 循环在每次迭代后会返回一个形式为 [key，value] 的数组
Map 默认情况不包含任何键。只包含显式插入的键 而Object有一个原型对象 原型对象上的键名可能跟我设置的键名一样
一个 Map 的键可以是任意值，包括函数、对象或任意基本类型	一个 Object 的键必须是一个 String 或是 Symbol

添加元素 set 方法 采用键值对 键值都可以是任意类型的数据 Map会记录插入元素的顺序
删除 Map中的元素 delete
Map中的元素个数 size属性
获取 Map 中的元素 get方法
清空 Map clear方法
 has方法检测 Map中是否包含某个元素 返回 booolean值
遍历 Map Map实现了 iterator 接口

ES5添加公共方法是在构造函数的原型对象上添加的，class类里面的方法也是添加在原型对象上的 Prototype
ES5给构造函数添加的属性在构造函数子身上 被称为静态成员 实例对象的方法是从构造函数的原型对象上找的 所以实例对象不能使用构造函数自己身上的方法
class类里面给属性绑定了 static 静态的意思 就变成了类里面的静态成员 实例对象也是不能访问的
1. 实例成员就是构造函数内部通过 this 添加的成员 就是实例成员 实例成员只能通过实例化的对象来访问
2. 静态成员 在构造函数本身上添加的成员 就是静态成员 
子类继承父类用 extends 继承的意思
super关键字调用父类构造函数 父类构造函数的原型对象指向父类构造函数本身 而父类的成员是在父类构造函数的原型对象上的 所以可以调用父类的方法属性
方法查找规则 先从子类构造函数的原型对象上找 在从父类构造函数的原型对象上找

在 javascript 中，如果试着改变一个属性的值，那么对应的 setter 将被执行。setter 经常和 getter 连用以创建一个伪属性。不可能在具有真实值的属性上同时拥有一个 setter 器
get语法将对象属性绑定到查询该属性时将被调用的函数
属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。
执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。
当尝试设置属性时，set语法将对象属性绑定到要调用的函数
set 绑定的属性必须要有一个形参 用来保存结果
属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。

 0b开头表示二进制
0o开头表示八进制
0x开头表示十六进制
0d表示十进制
Number.isFinite() 方法用来检测传入的参数是否是一个有穷数 有限的数 返回布尔值
 Number.isNaN() 方法确定传递的值是否为 NaN，并且检查其类型是否为 Number 表示未定义或不可表示的值 返回布尔值
Number.parseInt Number.parseFloat 将字符串转为整数
Number.isInteger 判断一个数是否为整数 返回布尔值
Math.trunc 将小数部分抹掉 1 0 -1 三种结果

 1. Object.is() 方法判断两个值是否为同一个值 返回布尔值
2. Object.assign() 分配 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象 它将返回目标对象 相同属性后面会覆盖前面的值
3. Object.setPrototypeOf(target， obj) 方法设置一个指定的对象的原型 到另一个对象或  null 
4. Object.getPrototypeOf() 方法返回指定对象的原型

ES6模块化 script标签需要声明type="module"
静态import引入
import 名字 from "绝对路径";  只限于默认暴露
import * as name from "module-name";
export 单个暴露出口
export {name, sing}; 统一暴露
export default{content} 默认暴露

includes() 包括 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false
indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1
2. ** 类似于 Math.pow()  求幂运算符（1**2）返回将第一个操作数加到第二个操作数的幂的结果。它等效于Math.pow，不同之处在于它也接受BigInts作为操作数

1. async 异步的意思 使用async关键字声明的函数 其中允许使用await关键字 async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为 而无需刻意地链式调用promise
2. async函数一定会返回一个promise对象 如果一个async函数的返回值看起来不是promise 那么它将会被隐式地包装在一个promise对象中 返回的 Promise对象状态有三种情况
1. 非 Promise 对象会被包装在一个 Promise对象中 并且状态为成功
2. 是 Promise对象状态由Promise对象内部的调用决定
3. 抛出一个错误返回的结果是失败状态
async函数可能包含0个或者多个await表达式 await表达式会暂停整个async函数的执行进程并出让其控制权 只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程
promise的解决值会被当作该await表达式的返回值 使用async / await关键字就可以在异步代码中使用普通的try / catch代码块。
await 等候的意思 操作符用于等待一个Promise 对象的结果 它只能在异步函数 async function 中使用
[返回值] = await 表达式; 表达式是一个 Promise 对象或者任何要等待的值 返回 Promise 对象的处理结果 如果等待的不是 Promise 对象 则返回该值本身
如果该值不是一个 Promise await 会把该值转换为已正常处理的Promise，然后等待其处理结果
如果 Promise 处理异常，则异常值被抛出
try...catch 尝试 接住的意思 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应
await 表达式会暂停当前 async function 的执行 等待 Promise 处理完成 若 Promise 正常处理(fulfilled) 其回调的resolve函数参数作为 await 表达式的值 继续执行 async function 
若 Promise 处理异常(rejected) await 表达式会把 Promise 的异常原因抛出 另外 如果 await 操作符后的表达式的值不是一个 Promise 则返回该值本身。

1. Object.keys() 方法返回一个对象的自身可枚举属性名组成的数组
2. Object.values() 方法返回一个对象自身的所有可枚举属性值的数组 ( 区别在于 for-in 循环枚举原型链中的属性 )
3. Object.entries() 进行的意思 方法返回一个对象自身可枚举属性的 键值对 数组
一个 Map 对象在迭代时会根据对象中元素的插入顺序来进行——一个 for...of 循环在每次迭代后会返回一个形式为 [key，value] 的数组
5. Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符
get得到 Own拥有 Property所有物 Descriptors描述符
 6. Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
Object.defineProperty(目标对象, 要修改的属性, {该属性的特性})
7. Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
Object.create(原型对象，{要定义其可枚举属性或修改的属性描述符的对象})
value: '尚硅谷'
writable: true, // 值可修改
enumerable: true, // 该数值可以被枚举遍历
configurable: true // 该属性可以被删除 该属性的特性可以被修改、

Rest 参数 与 spread 扩展运算符在 ES6 中已经引入 不过 ES6 中只针对数组 在 ES9 中为对象提供了像数组一样的 rest 参数和运算符
({ host, port, ...type }) 将对象作为参数传参 // 剩下的会组成一个对象
{...f1, ...f2, ...f3, ...f4} 合并一个对象 相同属性名会被去重 保留最后一个 f1 f2都是对象 ...f1 => q: '无敌'

 exec() 方法在一个指定字符串中执行一个搜索匹配 返回一个结果数组或 null
向前断言  x(?=y) 根据目标字符后面的字判断
向后断言 (?<=y)x 根据目标字符前面的字判断
dotAll 模式 dotAll 属性表明是否在正则表达式中一起使用"s"修饰符
如果使用了"s"修饰符，dotAll 的值将返回Boolean类型的true，否则将返回false
const reg = /<li>.*?<a>(.*?)<\/a>.*?<p>(.*?)<\/p>/gs;

Object.fromEntries() 方法把键值对列表转换为一个对象 把二维数组转换为对象 方法接收一个键值对的列表参数，
并返回一个带有这些键值对的新对象 执行与 Object.entries 互逆的操作
通过 Object.fromEntries， 可以将 Map 转换为 Object
Object.entries() 条目 方法返回一个给定对象自身可枚举属性的键值对数组 键值对的二维数组
trimStart 修剪字符串左侧 不会改变原来的字符串
trimEnd 修剪字符串右侧 不会改变原来的字符串
trim 修剪字符串两端空白 不会改变原来的字符串
flat() 平的 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回 参数默认是 1 就是深度 1 层 将多维数组转化任意维数组
flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些
flatMap 可以将 多维数组 变成 1维数组
Symbol.prototype.description 描述 是一个只读属性，它会返回 Symbol 对象的可选描述的字符串


私有属性 只能在类里访问 外部不能访问 以 # 开头 #age;
调用 Promise.allSettled() 方法 返回一个 promise 对象 但是它的状态始终是成功状态
Promise.allSettled([p1, p2]) 返回 一个数组 里面每个对象放着每个Promise对象的 状态 跟返回值
Promise.all() 也是返回一个Promise 对象 有一个 Promise 状态失败 就会返回失败 必须都成功才会返回成功状态
该Promise.allSettled()全部结算 方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise 返回一个对象组成的数组 里面每个对象是对应的Promise的状态跟值 
当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它 相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个reject时立即结束
String.prototype.matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器 可以使用 for of 枚举 或者使用扩展运算符将其转换为数组 里面包含这每次枚举的结果对象
?. 可选链操作符 类似于 && 前者为真返回后者 前者为假返回前者 避免没有这个参数产生报错
name?.sing?.name; // 如果传入了参数 name 并且里面有 sing 并且sing里面有name属性 否则返回 undefined
import(路径).then 方法动态引入文件 异步任务执行时引入 可以提升页面资源加载效率 返回一个 promise 对象 调用 then 方法
BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数
将整数转换为 bigint类型 BigInt() 只能转换整数不能转换小数
大数值运算 大数值运算 number会出问题 BigInt不会出问题
bigint 类型 不能跟整数 直接相加
全局属性 globalThis 包含全局的 this 值，类似于全局对象（global object）

Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，
不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改

